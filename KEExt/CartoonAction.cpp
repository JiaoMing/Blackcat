////  CartoonAction.cpp//  iFrameExtractor////  Created by shuang on 12-7-11.//  Copyright (c) 2012å¹´ __MyCompanyName__. All rights reserved.//#include "CartoonAction.h"#define kCartoonActionTag 10CartoonRepeatAction::~CartoonRepeatAction(){    CC_SAFE_RELEASE_NULL(m_pBodyAction);    CC_SAFE_RELEASE_NULL(m_pEyeAction);}CartoonRepeatAction * CartoonRepeatAction::actionWithCartoon(Cartoon *pCartoon, const char *pszActionName, int nTimes){    CartoonRepeatAction *pAction = new CartoonRepeatAction();    pAction->initWithCartoon(pCartoon, pszActionName, nTimes);    pAction->autorelease();        return pAction;}bool CartoonRepeatAction::initWithCartoon(Cartoon *pCartoon, const char *pszActionName, int nTimes){    MotionClip *clip = (MotionClip *)pCartoon->getClipConfigs()->objectForKey(std::string(pszActionName));    do {        std::string sBodyAnimation = clip->getBodyAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sBodyAnimation);                char fullname[100] = {0};        sprintf(fullname, "%s_%s.png", sBodyAnimation.c_str(), "1");        pCartoon->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                CCAnimation *animation = CCAnimation::create();        CCObject *pObject = NULL;        CCARRAY_FOREACH(animationConfig->getOrderArray(), pObject)        {            CCString *psOrder = (CCString *)pObject;            sprintf(fullname, "%s_%s.png", sBodyAnimation.c_str(), psOrder->m_sString.c_str());            animation->addSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));        }        animation->setDelayPerUnit(animationConfig->getTimer());        animation->setRestoreOriginalFrame(true);                if (nTimes <= 0) nTimes = 1;        m_pBodyAction = CCRepeat::create(CCAnimate::create(animation), nTimes);        m_pBodyAction->retain();    } while (0);        if (strlen(clip->getEyeAnimation())) {        std::string sEyeAnimation = clip->getEyeAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sEyeAnimation);                char fullname[100] = {0};		sprintf(fullname, "%s_%s.png", sEyeAnimation.c_str(), "1");        pCartoon->getEye()->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                pCartoon->getEye()->setPosition(ccp(animationConfig->getOffset().x, pCartoon->getContentSize().height - animationConfig->getOffset().y));        pCartoon->getEye()->setVisible(true);                CCAnimation *animation = CCAnimation::create();        CCObject *pObject = NULL;        CCARRAY_FOREACH(animationConfig->getOrderArray(), pObject)        {            CCString *psOrder = (CCString *)pObject;			sprintf(fullname, "%s_%s.png", sEyeAnimation.c_str(), psOrder->m_sString.c_str());            animation->addSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));        }        animation->setDelayPerUnit(animationConfig->getTimer());        animation->setRestoreOriginalFrame(true);                m_pEyeAction = CCAnimate::create(animation);        m_pEyeAction->retain();    } else {        pCartoon->getEye()->setVisible(false);        m_pEyeAction = NULL;    }        if (strlen(clip->getMouthAnimation())) {        std::string sMouthAnimation = clip->getMouthAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sMouthAnimation);                char fullname[100] = {0};		sprintf(fullname, "%s_%s.png", sMouthAnimation.c_str(), "1");        pCartoon->getMouth()->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                pCartoon->getMouth()->setPosition(ccp(animationConfig->getOffset().x, pCartoon->getContentSize().height - animationConfig->getOffset().y));        pCartoon->getMouth()->setVisible(true);    } else {        pCartoon->getMouth()->setVisible(false);    }        pCartoon->stopActionByTag(kCartoonActionTag);    pCartoon->getEye()->stopActionByTag(kCartoonActionTag);    pCartoon->getMouth()->stopActionByTag(kCartoonActionTag);    pCartoon->setClipName(pszActionName);    setTag(kCartoonActionTag);        if (CCActionInterval::initWithDuration(m_pBodyAction->getDuration())) {        return true;    }    return false;}void CartoonRepeatAction::startWithTarget(CCNode* pTarget){    Cartoon *pCartoon = (Cartoon *)pTarget;    CCActionInterval::startWithTarget(pTarget);    m_pBodyAction->startWithTarget(pTarget);    if (m_pEyeAction) {        m_pEyeAction->startWithTarget(pCartoon->getEye());        m_nRandomInterval = rand() % 5 + 4;        m_nEyeElapsed = 0;        m_bEyeWaiting = false;        m_fLastDt = 0.0f;    }}void CartoonRepeatAction::stop(){    m_pBodyAction->stop();    if (m_pEyeAction) {        m_pEyeAction->stop();    }    CCActionInterval::stop();}void CartoonRepeatAction::update(float dt){    m_pBodyAction->update(dt);    if (m_pEyeAction) {        float dtForEye = (dt - m_fLastDt) * m_fDuration;        m_fLastDt = dt;        if (m_bEyeWaiting) {            m_nEyeElapsed += dtForEye;            if (m_nEyeElapsed > m_nRandomInterval) {                Cartoon *pCartoon = (Cartoon *)m_pTarget;                float diff = m_nEyeElapsed - m_nRandomInterval;                m_pEyeAction->startWithTarget(pCartoon->getEye());                // to prevent jerk. issue #390, 1247                m_pEyeAction->step(0.0f);                m_pEyeAction->step(diff);                                m_nRandomInterval = rand() % 5 + 4;                m_nEyeElapsed = 0;                m_bEyeWaiting = false;            }        } else {            m_pEyeAction->step(dtForEye);            if (m_pEyeAction->isDone()) {                m_nEyeElapsed = m_pEyeAction->getElapsed() - m_pEyeAction->getDuration();                m_bEyeWaiting = true;            }        }    }}CartoonRepeatForeverAction::~CartoonRepeatForeverAction(){    CC_SAFE_RELEASE_NULL(m_pBodyAction);    CC_SAFE_RELEASE_NULL(m_pEyeAction);}CartoonRepeatForeverAction* CartoonRepeatForeverAction::actionWithCartoon(Cartoon *pCartoon, const char *pszActionName){    CartoonRepeatForeverAction* pAction = new CartoonRepeatForeverAction();    pAction->initWithCartoon(pCartoon, pszActionName);    pAction->autorelease();        return pAction;}bool CartoonRepeatForeverAction::initWithCartoon(Cartoon *pCartoon, const char *pszActionName){    MotionClip *clip = (MotionClip *)pCartoon->getClipConfigs()->objectForKey(std::string(pszActionName));    do {        std::string sBodyAnimation = clip->getBodyAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sBodyAnimation);                char fullname[100] = {0};        sprintf(fullname, "%s_%s.png", sBodyAnimation.c_str(), "1");        pCartoon->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                CCAnimation *animation = CCAnimation::create();        CCObject *pObject = NULL;        CCARRAY_FOREACH(animationConfig->getOrderArray(), pObject)        {            CCString *psOrder = (CCString *)pObject;            sprintf(fullname, "%s_%s.png", sBodyAnimation.c_str(), psOrder->m_sString.c_str());            animation->addSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));        }        animation->setDelayPerUnit(animationConfig->getTimer());        animation->setRestoreOriginalFrame(true);                m_pBodyAction = CCAnimate::create(animation);        m_pBodyAction->retain();    } while (0);        if (strlen(clip->getEyeAnimation())) {        std::string sEyeAnimation = clip->getEyeAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sEyeAnimation);        char fullname[100] = {0};		sprintf(fullname, "%s_%s.png", sEyeAnimation.c_str(), "1");        pCartoon->getEye()->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                pCartoon->getEye()->setPosition(ccp(animationConfig->getOffset().x, pCartoon->getContentSize().height - animationConfig->getOffset().y));        pCartoon->getEye()->setVisible(true);                CCAnimation *animation = CCAnimation::create();        CCObject *pObject = NULL;        CCARRAY_FOREACH(animationConfig->getOrderArray(), pObject)        {            CCString *psOrder = (CCString *)pObject;			sprintf(fullname, "%s_%s.png", sEyeAnimation.c_str(), psOrder->m_sString.c_str());            animation->addSpriteFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));        }        animation->setDelayPerUnit(animationConfig->getTimer());        animation->setRestoreOriginalFrame(true);                m_pEyeAction = CCAnimate::create(animation);        m_pEyeAction->retain();    } else {        pCartoon->getEye()->setVisible(false);        m_pEyeAction = NULL;    }        if (strlen(clip->getMouthAnimation())) {        std::string sMouthAnimation = clip->getMouthAnimation();        AnimationConfig *animationConfig = (AnimationConfig *)pCartoon->getAnimationConfigs()->objectForKey(sMouthAnimation);                char fullname[100] = {0};		sprintf(fullname, "%s_%s.png", sMouthAnimation.c_str(), "1");        pCartoon->getMouth()->setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()->spriteFrameByName(fullname));                pCartoon->getMouth()->setPosition(ccp(animationConfig->getOffset().x, pCartoon->getContentSize().height - animationConfig->getOffset().y));        pCartoon->getMouth()->setVisible(true);    } else {        pCartoon->getMouth()->setVisible(false);    }        pCartoon->stopActionByTag(kCartoonActionTag);    pCartoon->getEye()->stopActionByTag(kCartoonActionTag);    pCartoon->getMouth()->stopActionByTag(kCartoonActionTag);    pCartoon->setClipName(pszActionName);    setTag(kCartoonActionTag);        return true;}void CartoonRepeatForeverAction::startWithTarget(CCNode* pTarget){    Cartoon *pCartoon = (Cartoon *)pTarget;    CCActionInterval::startWithTarget(pTarget);    m_pBodyAction->startWithTarget(pTarget);    if (m_pEyeAction) {        m_pEyeAction->startWithTarget(pCartoon->getEye());        m_nRandomInterval = rand() % 5 + 4;        m_nEyeElapsed = 0;        m_bEyeWaiting = false;    }}void CartoonRepeatForeverAction::stop(){    m_pBodyAction->stop();    if (m_pEyeAction) {        m_pEyeAction->stop();    }    CCActionInterval::stop();}void CartoonRepeatForeverAction::step(float dt){    m_pBodyAction->step(dt);    if (m_pBodyAction->isDone())    {        float diff = m_pBodyAction->getElapsed() - m_pBodyAction->getDuration();        m_pBodyAction->startWithTarget(m_pTarget);        // to prevent jerk. issue #390, 1247        m_pBodyAction->step(0.0f);        m_pBodyAction->step(diff);    }    if (m_pEyeAction) {        if (m_bEyeWaiting) {            m_nEyeElapsed += dt;            if (m_nEyeElapsed > m_nRandomInterval) {                Cartoon *pCartoon = (Cartoon *)m_pTarget;                float diff = m_nEyeElapsed - m_nRandomInterval;                m_pEyeAction->startWithTarget(pCartoon->getEye());                // to prevent jerk. issue #390, 1247                m_pEyeAction->step(0.0f);                m_pEyeAction->step(diff);                                m_nRandomInterval = rand() % 5 + 4;                m_nEyeElapsed = 0;                m_bEyeWaiting = false;            }        } else {            m_pEyeAction->step(dt);            if (m_pEyeAction->isDone()) {                m_nEyeElapsed = m_pEyeAction->getElapsed() - m_pEyeAction->getDuration();                m_bEyeWaiting = true;            }        }    }}bool CartoonRepeatForeverAction::isDone(){    return false;}void CartoonRepeatForeverAction::update(float dt){    CCLog("%f",dt);}CartoonStopAction *CartoonStopAction::action(){    CartoonStopAction* pRet = new CartoonStopAction();        if (pRet) {        pRet->autorelease();    }        return pRet;}void CartoonStopAction::update(float dt){    Cartoon *pCartoon = (Cartoon *)m_pTarget;    pCartoon->stopActionByTag(kCartoonActionTag);    pCartoon->getEye()->stopActionByTag(kCartoonActionTag);    CCLog("%f",dt);}